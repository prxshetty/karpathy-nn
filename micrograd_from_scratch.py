# -*- coding: utf-8 -*-
"""micrograd_from_scratch.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IsNWipu29g60uJ1pS1py7s3ST_Adj3On
"""

# Commented out IPython magic to ensure Python compatibility.
import math
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

def f(x):
  return 3*x**2 -4*x+5

f(3.0)

xs=np.arange(-5, 5, 0.25)
ys=f(xs)
plt.plot(xs, ys)

h=0.01
x=2/3
(f(x+h)-f(x))/h

class Value:

  def __init__(self, data,_children=(),_op='', label=''):
    self.data=data
    self._op=_op
    self.grad=0.0
    self._backward=lambda:None
    self._prev=set(_children)
    self.label=label

  def __repr__(self):
    return f"Value(data={self.data})"

  def __add__(self, other):
    out=Value(self.data+other.data,(self, other), '+')

    def _backward():
      self.grad=1.0* out.grad
      other.grad=1.0 * out.grad
    out._backward=_backward

    return out

  def __mul__(self, other):
    out=Value(self.data * other.data,(self, other), '*')

    def _backward():
      self.grad=other.data*out.grad
      other.grad=self.data*out.grad
    out._backward=_backward

    return out

  def tanh(self):
    x=self.data
    t=(math.exp(2*x)-1)/(math.exp(2*x)+1)
    out=Value(t, (self, ), 'tanh')

    def _backward():
      self.grad=(1-t**2)*out.grad
    out._backward = _backward

    return out

  def backward(self):

    topo=[]
    visited=set()
    def build_topo(v):
      if v not in visited:
        visited.add(v)
        for child in v._prev:
          build_topo(child)
        topo.append(v)
    build_topo(self)
    topo

    self.grad=1.0
    for node in reversed(topo):
      node._backward()

a=Value(2.0, label='a')
b=Value(-3.0, label='b')
c=Value(10.0, label='c')
#(a.__mul__(b)).__add__c
e=a*b; e.label='e'
d=e+c; d.label='d'
f=Value(-2.0, label='f')
L=d*f; L.label='L'
L

d._prev

d._op

from graphviz import Digraph
def trace(root):
    nodes, edges = set(), set()
    def build(v):
        if v not in nodes:
            nodes.add(v)
            for child in v._prev:
                edges.add((child, v))
                build(child)
    build(root)
    return nodes, edges
def draw_dot(root):
  dot =Digraph(format='svg', graph_attr={'rankdir': 'LR'})
  nodes, edges=trace(root)
  for n in nodes:
    uid=str(id(n))
    dot.node(name=uid, label="{%s | data %.4f | grad %.4f}" % (n.label, n.data,n.grad), shape='record')
    if n._op:
      dot.node(name =uid + n._op, label=n._op)
      dot.edge(uid+n._op, uid)

  for n1, n2 in edges:
    dot.edge(str(id(n1)), str(id(n2))+n2._op)

  return dot

draw_dot(L)

a.grad=(-2.0*-3.0)
b.grad=(-2.0*2.0)

c.grad=-2.0
e.grad=-2.0

d.grad=-2.0
f.grad=4.0

L.grad=1.0

def lol():
  h=0.0001

  a=Value(2.0, label='a')
  b=Value(-3.0, label='b')
  c=Value(10.0, label='c')
  #(a.__mul__(b)).__add__c
  e=a*b; e.label='e'
  d=e+c; d.label='d'
  f=Value(-2.0, label='f')
  L=d*f; L.label='L'
  L1=L.data

  a=Value(2.0, label='a')
  a.data+=h
  b=Value(-3.0, label='b')
  c=Value(10.0, label='c')
  #(a.__mul__(b)).__add__c
  e=a*b; e.label='e'
  d=e+c; d.label='d'
  d.data
  f=Value(-2.0, label='f')
  L=d*f; L.label='L'
  L2=L.data

  print((L2-L1)/h)

lol()

"""WANT :
dL/dc = dL/dd*dd/dc
WE KNOW:
dL/dd = -2
dd/dc = 1

"""

#single optimization step
a.data+=0.01*a.grad
b.data+=0.01*b.grad
c.data+=0.01*c.grad
f.data+=0.01*f.grad

e=a*b;
d=e+c;
L=d*f;
print(L.data)

plt.plot(np.arange(-5,5,0.2), np.tanh(np.arange(-5, 5, 0.2))); plt.grid();

x1=Value(2.0, label='x1')
x2=Value(0.0, label='x2')
#weights of the neuron
w1=Value(-3.0, label='w1')
w2=Value(1.0, label='w2')
#bias of the neuron
b=Value(6.881373587019432, label='b')
x1w1=x1*w1; x1w1.label='x1*w1'
x2w2=x2*w2; x2w2.label='x2*w2'
x1w1x2w2=x1w1+x2w2; x1w1x2w2.label='x1w1+x2w2'
n=x1w1x2w2+b; n.label='n'
o=n.tanh(); o.label='o'

draw_dot(o)

o.backward()

o.grad=1.0
topo=[]
visited=set()
def build_topo(v):
  if v not in visited:
    visited.add(v)
    for child in v._prev:
      build_topo(child)
    topo.append(v)
build_topo(o)
topo
for node in reversed(topo):
  node._backward()

topo=[]
visited=set()
def build_topo(v):
  if v not in visited:
    visited.add(v)
    for child in v._prev:
      build_topo(child)
    topo.append(v)
build_topo(o)
topo

o.grad=1.0

o._backward()

n._backward()

b._backward()

x1w1x2w2._backward()

x2w2._backward()
x1w1._backward()

o.grad =1.0
x1w1x2w2.grad=0.5
b.grad=0.5
n.grad=0.5
x2w2.grad=0.5
x1w1.grad=0.5

x2.grad=x2w2.grad*w2.grad
x1.grad=w1.grad*x1w1.grad
w1.grad=x1.grad*x1w1.grad
w2.grad=x2.grad*x2w2.grad

1-o.data**2

