# -*- coding: utf-8 -*-
"""micrograd_from_scratch.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IsNWipu29g60uJ1pS1py7s3ST_Adj3On
"""

# Commented out IPython magic to ensure Python compatibility.
import math
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

def f(x):
  return 3*x**2 -4*x+5

f(3.0)

xs=np.arange(-5, 5, 0.25)
ys=f(xs)
plt.plot(xs, ys)

h=0.01
x=2/3
(f(x+h)-f(x))/h

class Value:
  def __init__(self, data,_children=(),_op='', label=''):
    self.data=data
    self._op=_op
    self.grad=0.0
    self._prev=set(_children)
    self.label=label
  def __repr__(self):
    return f"Value(data={self.data})"
  def __add__(self, other):
    out=Value(self.data+other.data,(self, other), '+')
    return out
  def __mul__(self, other):
    out=Value(self.data * other.data,(self, other), '*')
    return out


a=Value(2.0, label='a')
b=Value(-3.0, label='b')
c=Value(10.0, label='c')
#(a.__mul__(b)).__add__c
e=a*b; e.label='e'
d=e+c; d.label='d'
f=Value(-2.0, label='f')
L=d*f; L.label='L'
L

d._prev

d._op

from graphviz import Digraph
def trace(root):
    nodes, edges = set(), set()
    def build(v):
        if v not in nodes:
            nodes.add(v)
            for child in v._prev:
                edges.add((child, v))
                build(child)
    build(root)
    return nodes, edges
def draw_dot(root):
  dot =Digraph(format='svg', graph_attr={'rankdir': 'LR'})
  nodes, edges=trace(root)
  for n in nodes:
    uid=str(id(n))
    dot.node(name=uid, label="{%s | data %.4f | grad %.4f}" % (n.label, n.data,n.grad), shape='record')
    if n._op:
      dot.node(name =uid + n._op, label=n._op)
      dot.edge(uid+n._op, uid)

  for n1, n2 in edges:
    dot.edge(str(id(n1)), str(id(n2))+n2._op)

  return dot

draw_dot(L)

a.grad=(-2.0*-3.0)
b.grad=(-2.0*2.0)

c.grad=-2.0
e.grad=-2.0

d.grad=-2.0
f.grad=4.0

L.grad=1.0

def lol():
  h=0.0001

  a=Value(2.0, label='a')
  b=Value(-3.0, label='b')
  c=Value(10.0, label='c')
  #(a.__mul__(b)).__add__c
  e=a*b; e.label='e'
  d=e+c; d.label='d'
  f=Value(-2.0, label='f')
  L=d*f; L.label='L'
  L1=L.data

  a=Value(2.0, label='a')
  a.data+=h
  b=Value(-3.0, label='b')
  c=Value(10.0, label='c')
  #(a.__mul__(b)).__add__c
  e=a*b; e.label='e'
  d=e+c; d.label='d'
  d.data
  f=Value(-2.0, label='f')
  L=d*f; L.label='L'
  L2=L.data

  print((L2-L1)/h)

lol()

"""WANT :
dL/dc = dL/dd*dd/dc
WE KNOW:
dL/dd = -2
dd/dc = 1

"""

